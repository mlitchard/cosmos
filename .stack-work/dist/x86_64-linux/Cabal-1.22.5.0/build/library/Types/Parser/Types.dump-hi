
==================== FINAL INTERFACE ====================
2016-05-18 22:46:30.581783 UTC

interface cosmo_1iqUX5FQjOsHFaPsFk56bu:Types.Parser.Types 7103
  interface hash: ebe7faaf3ab9006eb4bcc029bc52c5d5
  ABI hash: d7a673792fd73894194715ce573dc435
  export-list hash: 607d928958d68131efee41a1b771977f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 170b487c54627fde601cea59af29d5e3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Types.Parser.Types.AdjPhrase{Types.Parser.Types.Adjective}
  Types.Parser.Types.Adjective
  Types.Parser.Types.Determiner
  Types.Parser.Types.Noun
  Types.Parser.Types.NounPhrase{Types.Parser.Types.Noun Types.Parser.Types.NounPhrase1 Types.Parser.Types.NounPhrase2}
  Types.Parser.Types.PrepPhrase{Types.Parser.Types.PrepPhrase Types.Parser.Types.Preposition}
  Types.Parser.Types.Preposition
  Types.Parser.Types.Sentence{Types.Parser.Types.Command Types.Parser.Types.Type1 Types.Parser.Types.Type2}
  Types.Parser.Types.Verb
  Types.Parser.Types.VerbPhrase{Types.Parser.Types.Verb Types.Parser.Types.VerbPhrase1}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
8d56e74b15f4590dd005c5a049ff9186
  $fShowAdjPhrase :: GHC.Show.Show Types.Parser.Types.AdjPhrase
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Parser.Types.AdjPhrase
                  Types.Parser.Types.$fShowAdjPhrase_$cshowsPrec
                  Types.Parser.Types.$fShowAdjPhrase_$cshow
                  Types.Parser.Types.$fShowAdjPhrase_$cshowList -}
8d56e74b15f4590dd005c5a049ff9186
  $fShowAdjPhrase1 :: Types.Parser.Types.AdjPhrase -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Parser.Types.AdjPhrase
                   w1 :: GHC.Base.String ->
                 case w of ww { Types.Parser.Types.Adjective ww1 ->
                 Types.Parser.Types.$w$cshowsPrec 0 ww1 w1 }) -}
87ae9ddb27a4e0dd5ca564cb4e690598
  $fShowAdjPhrase2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Adjective "#) -}
8d56e74b15f4590dd005c5a049ff9186
  $fShowAdjPhrase_$cshow ::
    Types.Parser.Types.AdjPhrase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Parser.Types.AdjPhrase ->
                 Types.Parser.Types.$fShowAdjPhrase_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8d56e74b15f4590dd005c5a049ff9186
  $fShowAdjPhrase_$cshowList ::
    [Types.Parser.Types.AdjPhrase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Parser.Types.AdjPhrase
                   Types.Parser.Types.$fShowAdjPhrase1) -}
8d56e74b15f4590dd005c5a049ff9186
  $fShowAdjPhrase_$cshowsPrec ::
    GHC.Types.Int -> Types.Parser.Types.AdjPhrase -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.Parser.Types.AdjPhrase
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Types.Parser.Types.Adjective ww3 ->
                 Types.Parser.Types.$w$cshowsPrec ww1 ww3 w2 } }) -}
1c00178442798f429f03a0d0754f90be
  $fShowNounPhrase :: GHC.Show.Show Types.Parser.Types.NounPhrase
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Parser.Types.NounPhrase
                  Types.Parser.Types.$fShowNounPhrase_$cshowsPrec
                  Types.Parser.Types.$fShowNounPhrase_$cshow
                  Types.Parser.Types.$fShowNounPhrase_$cshowList -}
1c00178442798f429f03a0d0754f90be
  $fShowNounPhrase1 ::
    Types.Parser.Types.NounPhrase -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Parser.Types.NounPhrase
                   w1 :: GHC.Base.String ->
                 Types.Parser.Types.$w$cshowsPrec1 0 w w1) -}
1c00178442798f429f03a0d0754f90be
  $fShowNounPhrase_$cshow ::
    Types.Parser.Types.NounPhrase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Parser.Types.NounPhrase ->
                 Types.Parser.Types.$fShowNounPhrase_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1c00178442798f429f03a0d0754f90be
  $fShowNounPhrase_$cshowList ::
    [Types.Parser.Types.NounPhrase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Parser.Types.NounPhrase
                   Types.Parser.Types.$fShowNounPhrase1) -}
1c00178442798f429f03a0d0754f90be
  $fShowNounPhrase_$cshowsPrec ::
    GHC.Types.Int -> Types.Parser.Types.NounPhrase -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.Parser.Types.NounPhrase
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.Parser.Types.$w$cshowsPrec1 ww1 w1 w2 }) -}
a69c3acb586659154878456d83409d92
  $fShowPrepPhrase :: GHC.Show.Show Types.Parser.Types.PrepPhrase
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Parser.Types.PrepPhrase
                  Types.Parser.Types.$fShowPrepPhrase_$cshowsPrec
                  Types.Parser.Types.$fShowPrepPhrase_$cshow
                  Types.Parser.Types.$fShowPrepPhrase_$cshowList -}
a69c3acb586659154878456d83409d92
  $fShowPrepPhrase1 ::
    Types.Parser.Types.PrepPhrase -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Parser.Types.PrepPhrase
                   w1 :: GHC.Base.String ->
                 Types.Parser.Types.$w$cshowsPrec2 0 w w1) -}
b28a1a9a7afe0f2986ccee0925cbba3b
  $fShowPrepPhrase2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Preposition "#) -}
8fd2314a2002c068980e5308da73e85a
  $fShowPrepPhrase3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PrepPhrase "#) -}
a69c3acb586659154878456d83409d92
  $fShowPrepPhrase_$cshow ::
    Types.Parser.Types.PrepPhrase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Parser.Types.PrepPhrase ->
                 Types.Parser.Types.$fShowPrepPhrase_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a69c3acb586659154878456d83409d92
  $fShowPrepPhrase_$cshowList ::
    [Types.Parser.Types.PrepPhrase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Parser.Types.PrepPhrase
                   Types.Parser.Types.$fShowPrepPhrase1) -}
a69c3acb586659154878456d83409d92
  $fShowPrepPhrase_$cshowsPrec ::
    GHC.Types.Int -> Types.Parser.Types.PrepPhrase -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.Parser.Types.PrepPhrase
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.Parser.Types.$w$cshowsPrec2 ww1 w1 w2 }) -}
d3b29721b361983dc6a10118e8d0d738
  $fShowSentence :: GHC.Show.Show Types.Parser.Types.Sentence
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Parser.Types.Sentence
                  Types.Parser.Types.$fShowSentence_$cshowsPrec
                  Types.Parser.Types.$fShowSentence_$cshow
                  Types.Parser.Types.$fShowSentence_$cshowList -}
d3b29721b361983dc6a10118e8d0d738
  $fShowSentence1 :: Types.Parser.Types.Sentence -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Parser.Types.Sentence
                   w1 :: GHC.Base.String ->
                 Types.Parser.Types.$w$cshowsPrec3 0 w w1) -}
fc2926ed7bd68fae945e7f6473b653b1
  $fShowSentence2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Command "#) -}
5d216a48b1bfca0584499dc170dee6d0
  $fShowSentence3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Type2 "#) -}
df2daaafe546e470db42c39a3882a407
  $fShowSentence4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Type1 "#) -}
b344bbe04e442d2a828f12167db40940
  $fShowSentence5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Verb "#) -}
104e157bdfa06959e721c0a56c1aebd8
  $fShowSentence6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VerbPhrase1 "#) -}
d3b29721b361983dc6a10118e8d0d738
  $fShowSentence_$cshow ::
    Types.Parser.Types.Sentence -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Parser.Types.Sentence ->
                 Types.Parser.Types.$fShowSentence_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d3b29721b361983dc6a10118e8d0d738
  $fShowSentence_$cshowList ::
    [Types.Parser.Types.Sentence] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Parser.Types.Sentence
                   Types.Parser.Types.$fShowSentence1) -}
d3b29721b361983dc6a10118e8d0d738
  $fShowSentence_$cshowsPrec ::
    GHC.Types.Int -> Types.Parser.Types.Sentence -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.Parser.Types.Sentence
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.Parser.Types.$w$cshowsPrec3 ww1 w1 w2 }) -}
77ad1d11d6879ca16c01b0276c3cdc15
  $fShowVerbPhrase :: GHC.Show.Show Types.Parser.Types.VerbPhrase
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Parser.Types.VerbPhrase
                  Types.Parser.Types.$fShowVerbPhrase_$cshowsPrec
                  Types.Parser.Types.$fShowVerbPhrase_$cshow
                  Types.Parser.Types.$fShowVerbPhrase_$cshowList -}
77ad1d11d6879ca16c01b0276c3cdc15
  $fShowVerbPhrase1 ::
    Types.Parser.Types.VerbPhrase -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Parser.Types.VerbPhrase
                   w1 :: GHC.Base.String ->
                 Types.Parser.Types.$w$cshowsPrec4 0 w w1) -}
77ad1d11d6879ca16c01b0276c3cdc15
  $fShowVerbPhrase_$cshow ::
    Types.Parser.Types.VerbPhrase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Parser.Types.VerbPhrase ->
                 Types.Parser.Types.$fShowVerbPhrase_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
77ad1d11d6879ca16c01b0276c3cdc15
  $fShowVerbPhrase_$cshowList ::
    [Types.Parser.Types.VerbPhrase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Parser.Types.VerbPhrase
                   Types.Parser.Types.$fShowVerbPhrase1) -}
77ad1d11d6879ca16c01b0276c3cdc15
  $fShowVerbPhrase_$cshowsPrec ::
    GHC.Types.Int -> Types.Parser.Types.VerbPhrase -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.Parser.Types.VerbPhrase
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.Parser.Types.$w$cshowsPrec4 ww1 w1 w2 }) -}
c488e150673ee8d859bc8e6f468fcf9c
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Types.Parser.Types.Adjective
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Types.Parser.Types.Adjective
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Types.Parser.Types.$fShowAdjPhrase2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w)))
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Types.Parser.Types.$fShowAdjPhrase2
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.shows6
                              (GHC.Show.showLitString
                                 ww1
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.shows6
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))))) }) -}
1c00178442798f429f03a0d0754f90be
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Types.Parser.Types.NounPhrase
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
a69c3acb586659154878456d83409d92
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Types.Parser.Types.PrepPhrase
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: Types.Parser.Types.PrepPhrase
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Types.Parser.Types.PrepPhrase b1 b2
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.Parser.Types.$fShowPrepPhrase3
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows6
                               (GHC.Show.showLitString
                                  b1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showSpace1
                                        (Types.Parser.Types.$w$cshowsPrec1 11 b2 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }
                   Types.Parser.Types.Preposition b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.Parser.Types.$fShowPrepPhrase2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.Parser.Types.$fShowPrepPhrase2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
d3b29721b361983dc6a10118e8d0d738
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> Types.Parser.Types.Sentence
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: Types.Parser.Types.Sentence
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Types.Parser.Types.Type1 b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          Types.Parser.Types.$w$cshowsPrec4
                            11
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (Types.Parser.Types.$w$cshowsPrec1 11 b2 x))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.Parser.Types.$fShowSentence4
                             (g w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.Parser.Types.$fShowSentence4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   Types.Parser.Types.Type2 b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          Types.Parser.Types.$w$cshowsPrec4
                            11
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (Types.Parser.Types.$w$cshowsPrec2 11 b2 x))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.Parser.Types.$fShowSentence3
                             (g w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.Parser.Types.$fShowSentence3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   Types.Parser.Types.Command b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.Parser.Types.$fShowSentence2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.Parser.Types.$fShowSentence2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
77ad1d11d6879ca16c01b0276c3cdc15
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Types.Parser.Types.VerbPhrase
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: Types.Parser.Types.VerbPhrase
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Types.Parser.Types.VerbPhrase1 b1 b2
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.Parser.Types.$fShowSentence6
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows6
                               (GHC.Show.showLitString
                                  b1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showSpace1
                                        (Types.Parser.Types.$w$cshowsPrec1 11 b2 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }
                   Types.Parser.Types.Verb b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.Parser.Types.$fShowSentence5
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.Parser.Types.$fShowSentence5
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
8d56e74b15f4590dd005c5a049ff9186
  data AdjPhrase = Adjective Types.Parser.Types.Adjective
dd2ed4822e8d4870dc2c9060b9270e8f
  type Adjective = GHC.Base.String
962d4e44cf6dc406bcc73e297e05f489
  type Determiner = GHC.Base.String
b9db8b86d43989287a81af311eaaa3a4
  type Noun = GHC.Base.String
1c00178442798f429f03a0d0754f90be
  data NounPhrase
    = NounPhrase1 Types.Parser.Types.Determiner
                  Types.Parser.Types.NounPhrase
    | NounPhrase2 Types.Parser.Types.Determiner
                  Types.Parser.Types.AdjPhrase
                  Types.Parser.Types.NounPhrase
    | Noun Types.Parser.Types.Noun
a69c3acb586659154878456d83409d92
  data PrepPhrase
    = PrepPhrase Types.Parser.Types.Preposition
                 Types.Parser.Types.NounPhrase
    | Preposition Types.Parser.Types.Preposition
506809a72d9a0f6d2ebedaad796d41d7
  type Preposition = GHC.Base.String
d3b29721b361983dc6a10118e8d0d738
  data Sentence
    = Type1 Types.Parser.Types.VerbPhrase Types.Parser.Types.NounPhrase
    | Type2 Types.Parser.Types.VerbPhrase Types.Parser.Types.PrepPhrase
    | Command Types.Parser.Types.Verb
bcc46603717f02925bc0e5b36f60f060
  type Verb = GHC.Base.String
77ad1d11d6879ca16c01b0276c3cdc15
  data VerbPhrase
    = VerbPhrase1 Types.Parser.Types.Verb Types.Parser.Types.NounPhrase
    | Verb Types.Parser.Types.Verb
instance GHC.Show.Show [Types.Parser.Types.AdjPhrase]
  = Types.Parser.Types.$fShowAdjPhrase
instance GHC.Show.Show [Types.Parser.Types.NounPhrase]
  = Types.Parser.Types.$fShowNounPhrase
instance GHC.Show.Show [Types.Parser.Types.PrepPhrase]
  = Types.Parser.Types.$fShowPrepPhrase
instance GHC.Show.Show [Types.Parser.Types.Sentence]
  = Types.Parser.Types.$fShowSentence
instance GHC.Show.Show [Types.Parser.Types.VerbPhrase]
  = Types.Parser.Types.$fShowVerbPhrase
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

